#generic targets for clean and install
define do_clean
clean_bin:
	@if [ -f "$(1)" ]; then \
		$(_CLEAN_BIN); \
		rm -f $(1); \
	fi
endef

define do_install
install:
	@if [ ! -f "$(2)/$(1)" ]; then \
		$(_INSTALL); \
		install -m 775 $(OUT_LIB_DIR)/$(1) $(2); \
	fi
endef

#generic rules.
$(ELF): $(OBJS)
	@$(_LD)
	@$(CC) -o $(ELF) $(OBJS) $(LDFLAGS) $(LIBS)

$(LIB_STATIC): $(OBJS)
	@$(_AR)
	@$(AR) -rcs $@ $(OBJS)

clean: clean_obj clean_bin

#the for loop is just for convenience, to see all the OBJS being removed
clean_obj:
	@for obj in $(OBJS); do \
		if [ -f $$obj ]; then \
			$(_CLEAN); \
			rm -f $$obj; \
		fi \
	done

#define a generic clean target
ifneq ($(strip $(ELF)),)
$(eval $(call do_clean,$(ELF)))
$(eval $(call do_install,$(notdir $(ELF)),$(INSTALL_BIN_DIR)))
else ifneq ($(strip $(LIB_STATIC)),)
$(eval $(call do_clean,$(LIB_STATIC)))
$(eval $(call do_install,$(notdir $(LIB_STATIC)),$(INSTALL_LIB_DIR)))
else ifneq ($(strip $(LIB_DYNAMIC)),)
$(eval $(call do_clean,$(LIB_DYNAMIC)))
$(eval $(call do_install,$(notdir $(LIB_DYNAMIC)),$(INSTALL_LIB_DIR)))
endif

#pattern rules
$(OUT_OBJ_DIR)/%.o: %.c
	@$(_CC)
	@$(CC) $(CFLAGS) -c -o $@ $<

$(OUT_OBJ_DIR)/%.o: %.cpp
	@$(_CXX)
	@$(CXX) $(CFLAGS) -c -o $@ $<

# "|" means that the rule are order-only rules, meaning that it is imposing an ordering to build the target (dirs must exist),
# but does not force the target to be updated if one of these rules are executed (which for dirs is handy since the timestamps are changing whenever a file 
# is added/removed or changed) 
$(OBJS): | $(OUT_BIN_DIR) $(OUT_LIB_DIR) $(OUT_OBJ_DIR) 

$(OUT_BIN_DIR):
	@mkdir -p $(OUT_BIN_DIR)

$(OUT_LIB_DIR):
	@mkdir -p $(OUT_LIB_DIR)

$(OUT_OBJ_DIR):
	@mkdir -p $(OUT_OBJ_DIR)

